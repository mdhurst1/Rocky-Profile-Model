#import modules
from RPM_CRN_Analysis_Functions import *
import matplotlib.pyplot as plt
from matplotlib import rcParams, cm
from scipy.spatial.distance import pdist
import pandas as pd
import numpy as np
import sys, os

# Set display options to show all rows and columns
pd.set_option('display.max_columns', None)

# setup workspace
Folder = "C:/Users/mh322u/OneDrive - University of Glasgow/NZ_2023/Modelling_Holcene_Terraces/Results/"
ResultsFolder = Folder + "20210213_large_simulation_2/"
PlotsFolder = Folder + "Plots/"

# locad the records and pick one
RecordFile = "TerraceRuns.xlsx"
RecordDF = pd.read_excel(Folder+RecordFile,sheet_name="Sheet1",header=0)

Record =RecordDF[((RecordDF["SeaLevel"] == 1) & (RecordDF["UpliftFreq"] == 3) & (RecordDF["Clustering"] == 1) 
    & (RecordDF["UpliftMag"] == 3) & (RecordDF["Subsidence"] == 1) & (RecordDF["InitSlope"] == 3) & (RecordDF["Tide"] == 1) 
    & (RecordDF["Weathering"] == 1) & (RecordDF["Resistance"] == 1) & (RecordDF["Waves"] == 2))]

RunID = Record.RunID.values[0]

def FindTerraces(Folder, RunID, MinWidth):

    # load the profile data
    ProfileFileName = str(RunID) + "_ShoreProfile.xz"
    Times, SeaLevels, Z, X = ReadShoreProfile(Folder+ProfileFileName)

    StartTime = Times[0]
    EndTime = Times[-1]
    Time = StartTime
    TimeInterval = 1000
    OldIndex = -9999

    if StartTime > EndTime:
        TimeInterval *= -1
        
    ### FIND TERRACES ###
    #calculate inverse of slope (i.e. dx/dz so cliffs are zero)
    Slope = np.gradient(X[-1])

    #fig3 = plt.figure(3,(9,9))
    #ax3a = fig3.add_subplot(211)
    #ax3a.plot(Slope,Z,'b.')
    #ax3a.set_xscale("symlog",linthresh=0.01)
    #ax3a.set_xlabel("Slope (m/m)")
    #ax3a.set_ylabel("Elevation (m)")

    # calculate curvature
    Curv = np.gradient(Slope)
    FinalX = X[-1]

    Mask = (np.abs(Slope) < 0.1001) & (np.abs(Curv) < 0.01)

    # Find terraces
    #ax3b = fig3.add_subplot(212)
    #ax3b.plot(Curv,Z,'r.')
    #ax3b.set_xscale("symlog",linthresh=0.01)
    #ax3b.set_xlabel("Curvature (1/m)")
    #ax3b.set_ylabel("Elevation (m)")

    # Find cliff incides
    SteepIndices = np.where(Mask == 1)[0]

    # Find consecutive patches 
    SteepPatches = np.split(SteepIndices, np.where(np.diff(SteepIndices) != 1)[0] + 1)
    NPatches = len(SteepPatches)

    # Check if patches are close and merge accordingly
    DistanceThreshold = 2
    MergedPatches = []

    # Function to merge patches iteratively
    # modified from code generated by ChatGPT3.5
    def merge_patches(patches, distance, distance_threshold):
        merged_patches = patches.copy()
        merged = True

        while merged:
            merged = False
            i = 0

            while i < len(merged_patches) - 1:
                j = i + 1

                while j < len(merged_patches):
                    if (distance[merged_patches[i][-1]]-distance[merged_patches[j][0]]) < distance_threshold:
                        # Merge patches[i] and patches[j]
                        merged_patches[i] = np.concatenate([merged_patches[i], merged_patches[j]])
                        del merged_patches[j]
                        merged = True
                    else:
                        j += 1

                i += 1

        return merged_patches
        
    # Merge patches iteratively
    MergedPatches = merge_patches(SteepPatches, FinalX, MinTerraceWidth)

    
    # Function to find remaining gaps
    # generated by ChatGPT3.5
    def find_remaining_gaps(merged_patches):
        remaining_gaps = []
        last_end = -1

        for patch in merged_patches:
            if last_end != -1 and patch[0] - last_end > 1:
                remaining_gaps.append(np.arange(last_end + 1, patch[0]))

            last_end = patch[-1]

        return remaining_gaps

    # Find remaining gaps
    TerracePatches = find_remaining_gaps(MergedPatches)
    #TerracePatches = merge_patches(TerracePatches,FinalX, MinTerraceWidth)

    # Save Terraces to a new DF
    Columns = ["TerraceID","StartIndex","EndIndex","Width","MeanElev","ElevChange","Slope"]
    TerracesDF = pd.DataFrame(columns=Columns)
    
    for i, Terrace in enumerate(TerracePatches):
        Width = X[Terrace[0]]-X[Terrace[-1]]
        ElevChange = Z[Terrace[0]]-Z[Terrace[-1]]
        NewRow = [i,Terrace[0],Terrace[-1],Width,np.mean(Z[Terrace]),ElevChange,ElevChange/Width]
        TerracesDF = pd.concat([TerracesDF,pd.DataFrame([NewRow], columns=Columns)], ignore_index=True)
        
    TerracesDF.to_excel(Folder + str(RunID)+"_Terraces.xlsx")

def PlotTerraces(Folder, RunID):
    
    ResultsFolder = Folder + "Results/"
    PlotsFolder = Folder + "Plots/"
    
    # load the profile data
    ProfileFileName = str(RunID) + "_ShoreProfile.xz"
    Times, SeaLevels, Z, X = ReadShoreProfile(ResultsFolder+ProfileFileName)
    FinalX = X[-1]
    
    # load terraces 
    TerraceFile = str(RunID) + "_Terraces.xlsx"
    
    #check if file exists and run terrace finder if needed
    if not os.path.exists(ResultsFolder+TerraceFile):
        FindTerraces(Folder, RunID)
    
    TerracesDF = pd.read_excel(TerraceFile)
        
    # figure properties
    # Set up fonts for plots
    rcParams['font.family'] = 'sans-serif'
    rcParams['font.sans-serif'] = ['arial']
    rcParams['font.size'] = 16

    # create figure and axes
    fig1 = plt.figure(1,figsize=(16,9))
    ax1 = fig1.add_subplot(111)
    ax1.set_ylabel("Elevation (m)")
    ax1.set_xlabel("Distance (m)")

    # set colour map
    ColourMap = cm.bone

    #set up and loop over time to plot
    Time = Times[0]
    TimeInterval = 1000
    StartTime = Time
    EndTime = Times[-1]
    OldIndex=-9999
    
    while Time >= EndTime:
    
        # Find time
        Index = np.argmin(np.abs(Time-Times))
    
        if Index == OldIndex:
            break
        
        OldIndex = Index
        
        # plot final result on ax0
        Label = str(int(Time)) + " years"
        Colour = ColourMap(Time/np.max([StartTime,EndTime]))
        ax1.plot(X[Index], Z, ls="-", color=Colour, label=Label)

        Time += TimeInterval

    for Terrace in TerracesDF:
        ax1.plot(FinalX[Terrace.StartIndex:Terrace.EndIndex],Z[Terrace.StartIndex:Terrace.EndIndex],'r-', lw=2, zorder=9)

    fig1.savefig(PlotsFolder+str(RunID)+"_ProfilePlot.png")

# # PLOT SEA LEVEL CURVE
# SeaDF = pd.read_csv(ResultsFolder + str(RunID) + "_rsl.data", delimiter=" ", header=0)

# # plot the profile
# fig2 = plt.figure(2,figsize=(16,9))
# ax2 = fig2.add_subplot(111)
# ax2.set_ylabel("Relative Sea Level (m)")
# ax2.set_xlabel("Time (years BP)")
# ax2.plot(SeaDF["Time"],SeaDF["RSL"],'b-')
# ax2.set_xlim(SeaDF["Time"].max(),SeaDF["Time"].min())
# ax2.set_ylim(SeaDF["RSL"].min(),SeaDF["RSL"].max()+5)
# fig2.savefig(PlotsFolder+str(RunID)+"_ProfilePlot.png")

# # ADD EARTHQUAKES

