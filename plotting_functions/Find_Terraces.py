#import modules
from RPM_CRN_Analysis_Functions import *
import matplotlib.pyplot as plt
from matplotlib import rcParams, cm
from scipy.interpolate import interp1d
from scipy.ndimage import gaussian_filter1d
import pandas as pd
import numpy as np
import sys, os
from tqdm import tqdm
import pdb

# dont plot in spyder pls
#%matplotlib qt5
plt.switch_backend('Agg')

# figure properties
# Set up fonts for plots
rcParams['font.family'] = 'sans-serif'
rcParams['font.sans-serif'] = ['arial']
rcParams['font.size'] = 16

def GetRunRecord(Folder, RunID):
    
    """
    
    Retrieves a record of a model run based on a RunID
    
    MDH, Dec 2023
    
    """
    
    # locad the records and pick one
    RecordFile = "TerraceRuns.xlsx"
    RecordDF = pd.read_excel(Folder+RecordFile,sheet_name="Sheet1",header=0)
    
    Record = RecordDF[(RecordDF["RunID"] == RunID)]
    
    return Record

def FindClusterTerraces(Folder, RunID, MinWidth=3.):
    """
    Functio to find terraces as clusters of elevation when viewing Z 
    as a function of X
    
    Need to figure out how to get X as a function of Z first
    Do this later
    
    MDH, Dec 2023
    
    Parameters
    ----------
    Folder : TYPE
        DESCRIPTION.
    RunID : TYPE
        DESCRIPTION.
    MinWidth : TYPE, optional
        DESCRIPTION. The default is 3..

    Returns
    -------
    None.

    """
    
    ResultsFolder = Folder + "Results/"
    PlotsFolder = Folder + "Plots/"
    
    # load the profile data
    ProfileFileName = str(RunID) + "_ShoreProfile.xz"
    Times, SeaLevels, Z, X = ReadShoreProfile(ResultsFolder+ProfileFileName)
    FinalX = X[-1]
    dZ = np.round(Z[1]-Z[0],1)

    StartTime = Times[0]
    EndTime = Times[-1]
    Time = StartTime
    TimeInterval = 1000
    OldIndex = -9999

    if StartTime > EndTime:
        TimeInterval *= -1
        
    #get a view of X in the Z dimension via interpolation to help find flats?
    NewX = np.arange(FinalX[0],FinalX[-1],dZ)
    #interp_func = interp1d(FinalX,Z, kind='linear')
    #NewZ = interp_func(NewX)
    
    # Function to find the indices of the two nearest points
    # generated by chatGPT
    def find_nearest_indices(x, y, target_x):
        distances = np.sqrt((x - target_x)**2 + (y - y[0])**2)  # Distance to each point
        nearest_indices = np.argsort(distances)[:2]  # Indices of the two nearest points
        return nearest_indices

    # Find the two nearest points for each interpolation point
    nearest_indices = [find_nearest_indices(FinalX, Z, target_x) for target_x in NewX]

    # Perform linear interpolation between the two nearest points
    interpolated_Z = [
        np.interp(target_x, FinalX[indices], Z[indices])
        for target_x, indices in zip(NewX, nearest_indices)
    ]


    # plot the profile
    plt.plot(FinalX,Z,'r-')
    plt.plot(NewX,interpolated_Z, 'k.')
    plt.show()
    
    
def FindUpliftTerraces(Folder, RunID, MinWidth=3., MaxWaveHeight=2.):
    
    """
    Function that should replicate Hiro's approach to finding
    terraces created during an uplift event.
    
    Finds the RSL at the time of uplift then looks for 
    the topography within half a tide range of that elevation
    in the final profile
    
    MDH, Dec 2023
    
    """
    
    ResultsFolder = Folder + "Results/"
    PlotsFolder = Folder + "Plots/"
    
    # load the profile data
    ProfileFileName = str(RunID) + "_ShoreProfile.xz"
    Times, SeaLevels, Z, X = ReadShoreProfile(ResultsFolder+ProfileFileName)
    FinalX = X[-1]
    dZ = np.round(Z[1]-Z[0],1)

    StartTime = Times[0]
    EndTime = Times[-1]
    Time = StartTime
    TimeInterval = 1000
    OldIndex = -9999

    if StartTime > EndTime:
        TimeInterval *= -1
    
    # load uplift history
    UpliftDF = pd.read_csv(ResultsFolder+str(RunID)+"_uplift_RSL.data", header=None, names=["Time","Mag","RSL"])
    
    # retrieve parameters
    RunRecord = GetRunRecord(Folder, RunID)
    Tide = RunRecord["Tide"].values[0]
    
    # Save Terraces to a new DF
    Columns = ["TerraceID","StartIndex","EndIndex","Width","MeanElev","ElevChange","Slope"]
    EQTerracesDF = pd.DataFrame(columns=Columns)
    
    # loop through uplift events
    for i, Earthquake in UpliftDF.iterrows():
        
        # find tides either side of RSL at time of EQ
        # also subtract breaking wave water depth from low tide limit
        LowTideInd = np.argmin(np.abs((Earthquake['RSL']+Earthquake["Mag"]- 0.5*Tide - (MaxWaveHeight/0.78)) - Z))
        HighTideInd = np.argmin(np.abs((Earthquake['RSL']+Earthquake["Mag"] + 0.5*Tide) - Z))
        
        # if there is no terrace, there's no terrace
        if LowTideInd == HighTideInd:
            continue
        
        # check min and max
        MinInd = LowTideInd
        
        # check for notches
        MaxInd = HighTideInd+np.argmax(FinalX[HighTideInd:LowTideInd])
        
        # get the last value so as not to include the cliff
        if HighTideInd == MaxInd:
            Indices = np.where(FinalX[HighTideInd:LowTideInd] == FinalX[MaxInd])[0]
            MaxInd += np.max(Indices)
        
        # record a terrace if wide enough
        Width = FinalX[MaxInd]-FinalX[MinInd]
        
        if Width < MinWidth:
            continue
            
        ElevChange = Z[MaxInd]-Z[MinInd]
        
        # create record and add to DF
        NewRow = [i,MaxInd,MinInd,Width,np.mean(Z[MaxInd:MinInd+1]),ElevChange,ElevChange/Width]
        EQTerracesDF = pd.concat([EQTerracesDF,pd.DataFrame([NewRow], columns=Columns)], ignore_index=True)
        
    # write to file
    EQTerracesDF.to_excel(ResultsFolder + str(RunID)+"_EQ_Terraces.xlsx")
        
    return EQTerracesDF
    
    
def FindTerraces(Folder, RunID, MaxSlope=0.1, MinWidth=3.):

    ResultsFolder = Folder + "Results/"
    PlotsFolder = Folder + "Plots/"
    
    # load the profile data
    ProfileFileName = str(RunID) + "_ShoreProfile.xz"
    Times, SeaLevels, Z, X = ReadShoreProfile(ResultsFolder+ProfileFileName)
    FinalX = X[-1]
    dZ = np.round(Z[1]-Z[0],1)

    StartTime = Times[0]
    EndTime = Times[-1]
    Time = StartTime
    TimeInterval = 1000
    OldIndex = -9999

    if StartTime > EndTime:
        TimeInterval *= -1
    
    # load uplift history
    # UpliftDF = pd.read_csv(ResultsFolder+str(RunID)+"_uplift_RSL.data", header=None, names=["Time","Mag","RSL"])
    
    # fig1 = plt.figure(1,(16,9))
    # ax = fig1.add_subplot(111)
    # plt.plot(FinalX,Z,'-',c=[0.5,0.5,0.5])
    
    # do some smoothing?
    # Apply Gaussian smoothing only to the masked part with a small standard deviation
    sigma = 2
    SmoothX = gaussian_filter1d(FinalX, sigma=sigma, mode='nearest')

    # plt.plot(SmoothX,Z,'k.-')
    
    ### FIND TERRACES ###
    #calculate inverse of slope (i.e. dx/dz so cliffs are zero)
    ZGrad = np.gradient(SmoothX)
    ZGrad[ZGrad == 0] = 0.001
    Slope = dZ/ZGrad
            
    # calculate curvature
    Curv = np.gradient(Slope)
    
    # # Find terraces
    # fig3 = plt.figure(3,(9,9))
    
    # ax3a = fig3.add_subplot(211)
    # ax3a.plot(Slope,Z,'b.')
    # ax3a.set_xscale("symlog",linthresh=0.01)
    # ax3a.set_xlabel("Slope (m/m)")
    # ax3a.set_ylabel("Elevation (m)")

    # ax3b = fig3.add_subplot(212)
    # ax3b.plot(Curv,Z,'r.')
    # ax3b.set_xscale("symlog",linthresh=0.01)
    # ax3b.set_xlabel("Curvature (1/m)")
    # ax3b.set_ylabel("Elevation (m)")
    
    # get Z as a function of X
    #dZ = np.round(Z[1]-Z[0],1)
    
    #get a view of X in the Z dimension via interpolation to help find flats?
    #NewX = np.arange(FinalX[0],FinalX[-1],dZ)
    #interp_func = interp1d(FinalX,Z, kind='linear', fill_value='extrapolate')
    #NewZ = interp_func(NewX)
    
    #RealSlope = np.gradient(NewZ)
    #RealCurv = np.gradient(RealSlope)
    #fig1 = plt.figure(1,(16,9))
    #ax1 = fig1.add_subplot(211)
    #ax1.plot(FinalX,Z,'k-')
    #ax1.plot(NewX,NewZ,'b-')
    
    #ax2 = fig1.add_subplot(212)
    #ax2.set_yscale("symlog",linthresh=0.01)
    #ax2.plot(NewX,RealSlope,'b.')
    
    # Mask to find steep sections with low curvature
    Mask = (np.abs(Slope) > MaxSlope)
    
    #Mask2 = ()
    # ax.plot(FinalX[Mask], Z[Mask],'r.')
    # ax.plot(FinalX[~Mask], Z[~Mask],'b.')
    
    
        
    # Find cliff indices
    SteepIndices = np.where(Mask == 1)[0]
    # GentleIndices = np.where(Mask == 0)[0]
    
    #smooth the inbetween bits
    
    # In gentle areas, further mask by slope
    #DiffX = np.insert(np.diff(X[-1]),-1,0)
    
    # Find terrace indices
    #GentleMask = ((Mask == 0) & (np.abs(Slope) > 1))
    #TerraceIndices = np.where(GentleMask == 1)[0]
    
    
    # Find consecutive patches 
    SteepPatches = np.split(SteepIndices, np.where(np.diff(SteepIndices) != 1)[0] + 1)
    #NPatches = len(TerracePatches)
    
    #print(TerracePatches)

    # Check if patches are close and merge accordingly
    DistanceThreshold = MinWidth

    # Function to merge patches iteratively
    # modified from code generated by ChatGPT3.5
    def merge_patches(patches, distance, distance_threshold):
        merged_patches = patches.copy()
        merged = True

        while merged:
            merged = False
            i = 0

            while i < len(merged_patches) - 1:
                j = i + 1

                while j < len(merged_patches):
                    if (distance[merged_patches[i][-1]]-distance[merged_patches[j][0]]) < distance_threshold:
                        # Merge patches[i] and patches[j]
                        merged_patches[i] = np.arange(merged_patches[i][0],merged_patches[j][-1]+1)
                        #np.concatenate([merged_patches[i], merged_patches[j]])
                        del merged_patches[j]
                        merged = True
                    else:
                        j += 1

                i += 1

        return merged_patches
        
    # Merge patches iteratively
    # for i, Patch in enumerate(SteepPatches):
        
    #     ax.plot(FinalX[Patch], Z[Patch],'r-')
    
    # sys.exit()
    
    SteepPatches = merge_patches(SteepPatches, FinalX, DistanceThreshold)
    
    
    
    
    
    # Function to find remaining gaps
    # generated by ChatGPT3.5
    def find_remaining_gaps(merged_patches):
        remaining_gaps = []
        last_end = -1

        for patch in merged_patches:
            if last_end != -1 and patch[0] - last_end > 1:
                remaining_gaps.append(np.arange(last_end + 1, patch[0]))

            last_end = patch[-1]

        return remaining_gaps

    # Find remaining gaps
    if len(SteepPatches) > 1:
        GentlePatches = find_remaining_gaps(SteepPatches)
        GentlePatches = merge_patches(GentlePatches, Z, 1.)
    
    else:
        GentlePatches = []
    
    #for i, Patch in enumerate(GentlePatches):
        # ax.plot(FinalX[Patch], Z[Patch],'b-')
    
    # Smooth Gentle Patches
    # SmoothX = FinalX
    # for i, Patch in enumerate(GentlePatches):
    #     print(Patch)
    #     SmoothX[Patch] = savgol_filter(FinalX[Patch],11,2)
        
    # for i, Patch in enumerate(SteepPatches):
    #     plt.plot(FinalX[Patch],Z[Patch],'r-')
    
    # plt.plot(SmoothX,Z,'r.')
    # plt.show()
    # sys.exit()
    
    # Save Terraces to a new DF
    Columns = ["TerraceID","StartIndex","EndIndex","Width","MeanElev","ElevChange","Slope"]
    TerracesDF = pd.DataFrame(columns=Columns)
    
    for i, Terrace in enumerate(GentlePatches):
        Width = FinalX[Terrace[0]]-FinalX[Terrace[-1]]
        if Width < MinWidth:
            continue
        
        ElevChange = Z[Terrace[0]]-Z[Terrace[-1]]
        NewRow = [i,Terrace[0],Terrace[-1],Width,np.mean(Z[Terrace]),ElevChange,ElevChange/Width]
        TerracesDF = pd.concat([TerracesDF,pd.DataFrame([NewRow], columns=Columns)], ignore_index=True)
    
    TerracesDF.to_excel(ResultsFolder + str(RunID)+"_Terraces.xlsx")
    
    return TerracesDF

def FindTerracesRaw(X, Z, MaxSlope=0.1, MinWidth=3.):

    # do some smoothing?
    # Apply Gaussian smoothing only to the masked part with a small standard deviation
    SmoothX = gaussian_filter1d(X, sigma=2, mode='nearest')

    #calculate inverse of slope (i.e. dx/dz so cliffs are zero)
    ZGrad = np.gradient(SmoothX)
    ZGrad[ZGrad == 0] = 0.001
    dZ = np.round(Z[1]-Z[0],1)
    Slope = dZ/ZGrad
            
    # calculate curvature
    Curv = np.gradient(Slope)
    
    # Mask to find steep sections
    Mask = (np.abs(Slope) > MaxSlope)
    
    # Find cliff indices
    SteepIndices = np.where(Mask == 1)[0]
        
    # Find consecutive patches 
    SteepPatches = np.split(SteepIndices, np.where(np.diff(SteepIndices) != 1)[0] + 1)
    
    # Check if patches are close and merge accordingly
    DistanceThreshold = MinWidth

    # Merge patches iteratively
    SteepPatches = merge_patches(SteepPatches, X, DistanceThreshold)
    
    # Find remaining gaps
    if len(SteepPatches) > 1:
        GentlePatches = find_remaining_gaps(SteepPatches)
        GentlePatches = merge_patches(GentlePatches, Z, 1.)
    
    else:
        GentlePatches = []
    
    # Save Terraces to a new DF
    Columns = ["TerraceID","StartIndex","EndIndex","Width","MeanElev","ElevChange","Slope"]
    TerracesDF = pd.DataFrame(columns=Columns)
    
    for i, Terrace in enumerate(GentlePatches):
        Width = X[Terrace[0]]-X[Terrace[-1]]
        if Width < MinWidth:
            continue
        
        ElevChange = Z[Terrace[0]]-Z[Terrace[-1]]
        NewRow = [i,Terrace[0],Terrace[-1],Width,np.mean(Z[Terrace]),ElevChange,ElevChange/Width]
        TerracesDF = pd.concat([TerracesDF,pd.DataFrame([NewRow], columns=Columns)], ignore_index=True)
    
    # TerracesDF.to_excel(ResultsFolder + str(RunID)+"_Terraces.xlsx")
    
    return TerracesDF

def PlotTerraces(Folder, RunID, EQ_Only=False):
    
    ResultsFolder = Folder + "Results/"
    PlotsFolder = Folder + "Plots/"

    # load the profile data
    ProfileFileName = str(RunID) + "_ShoreProfile.xz"
    Times, SeaLevels, Z, X = ReadShoreProfile(ResultsFolder+ProfileFileName)
    FinalX = X[-1]
    
    # load terraces 
    if EQ_Only:
        TerraceFile = str(RunID) + "_EQ_Terraces.xlsx"
    
    else:
        TerraceFile = str(RunID) + "_Terraces.xlsx"
    
    #check if file exists and run terrace finder if needed
    if not os.path.exists(ResultsFolder+TerraceFile):
        print("No Terrace file, cannot plot")
        sys.exit()
    
    TerracesDF = pd.read_excel(ResultsFolder+TerraceFile)
    
    N_Terraces = len(TerracesDF)
    
    N_Uplift = len(pd.read_csv(ResultsFolder+str(RunID)+"_episodic_uplift.data", header=None))
    
    # create figure and axes
    fig1 = plt.figure(1,figsize=(16,9))
    ax1 = fig1.add_subplot(111)
    ax1.set_ylabel("Elevation (m)")
    ax1.set_xlabel("Distance (m)")

    # set colour map
    ColourMap = cm.bone

    #set up and loop over time to plot
    Time = Times[0]
    TimeInterval = -1000
    StartTime = Time
    EndTime = Times[-1]
    OldIndex=-9999
    
    while Time >= EndTime:
        
        # Find time
        Index = np.argmin(np.abs(Time-Times))
    
        if Index == OldIndex:
            break
        
        OldIndex = Index
        
        # plot final result on ax0
        Label = str(int(Time)) + " years"
        Colour = ColourMap(Time/np.max([StartTime,EndTime]))
        ax1.plot(X[Index], Z, ls="-", color=Colour, label=Label)

        Time += TimeInterval

    for i,Terrace in TerracesDF.iterrows():
        
        # make sure indices are ints
        Ind1 = Terrace.StartIndex.astype(int)
        Ind2 = Terrace.EndIndex.astype(int)
        ax1.plot(FinalX[Ind1:Ind2],Z[Ind1:Ind2],'r-', lw=2, zorder=9)
    
    ax1.text(0.05,0.9,"No. Terraces: " + str(len(TerracesDF))+"\n"
             + "Kappa: " + str(np.round(N_Terraces/N_Uplift,2)), transform=ax1.transAxes)
    fig1.savefig(PlotsFolder+str(RunID)+"_ProfilePlot.png")
    #plt.show()
    fig1.clf()

def PlotRSL(Folder, RunID):
    
    ResultsFolder = Folder + "Results/"
    PlotsFolder = Folder + "Plots/"
    
    # # PLOT SEA LEVEL CURVE
    SeaDF = pd.read_csv(ResultsFolder + str(RunID) + "_rsl.data", delimiter=" ", header=0)
    
    # plot the profile
    fig2 = plt.figure(2,figsize=(16,9))
    ax2 = fig2.add_subplot(111)
    ax2.set_ylabel("Relative Sea Level (m)")
    ax2.set_xlabel("Time (years BP)")
    ax2.plot(SeaDF["Time"],SeaDF["RSL"],'b-')
    ax2.set_xlim(SeaDF["Time"].max(),SeaDF["Time"].min())
    ax2.set_ylim(SeaDF["RSL"].min(),SeaDF["RSL"].max()+5)
    fig2.savefig(PlotsFolder+str(RunID)+"_ProfilePlot.png")
    #plt.show()#fig2.clf()

# Function to find remaining gaps
# generated by ChatGPT3.5
def find_remaining_gaps(merged_patches):
    remaining_gaps = []
    last_end = -1

    for patch in merged_patches:
        if last_end != -1 and patch[0] - last_end > 1:
            remaining_gaps.append(np.arange(last_end + 1, patch[0]))

        last_end = patch[-1]

    return remaining_gaps

# Function to merge patches iteratively
# modified from code generated by ChatGPT3.5
def merge_patches(patches, distance, distance_threshold):
    merged_patches = patches.copy()
    merged = True

    while merged:
        merged = False
        i = 0

        while i < len(merged_patches) - 1:
            j = i + 1

            while j < len(merged_patches):
                if (distance[merged_patches[i][-1]]-distance[merged_patches[j][0]]) < distance_threshold:
                    # Merge patches[i] and patches[j]
                    merged_patches[i] = np.arange(merged_patches[i][0],merged_patches[j][-1]+1)
                    #np.concatenate([merged_patches[i], merged_patches[j]])
                    del merged_patches[j]
                    merged = True
                else:
                    j += 1

            i += 1

    return merged_patches
# # ADD EARTHQUAKES

if __name__ == "__main__":
    
    # Set display options to show all rows and columns
    # pd.set_option('display.max_columns', None)

    # setup workspace
    Folder = "C:/Users/mh322u/OneDrive - University of Glasgow/NZ_2023/Modelling_Holcene_Terraces/Results/"
    
    # locad the records and pick one
    RecordFile = "TerraceRuns.xlsx"
    RecordDF = pd.read_excel(Folder+RecordFile,sheet_name="Sheet1",header=0)
    
    # Minimum Width (default is 3m)
    # Max Slope (default is 0.1 m/m)
    # MinWidth=3.

    #Record =RecordDF[((RecordDF["SeaLevel"] == 1) & (RecordDF["UpliftFreq"] == 3) & (RecordDF["Clustering"] == 1) 
    #    & (RecordDF["UpliftMag"] == 3) & (RecordDF["Subsidence"] == 1) & (RecordDF["InitSlope"] == 3) & (RecordDF["Tide"] == 1) 
    #    & (RecordDF["Weathering"] == 1) & (RecordDF["Resistance"] == 1) & (RecordDF["Waves"] == 2))]

    # RunID = Record.RunID.values[0]
    RunID = 2198
    FindClusterTerraces(Folder, RunID)
    
    #PlotTerraces(Folder, RunID, EQ_Only=True) 
    #FindUpliftTerraces(Folder, RunID)
    #PlotTerraces(Folder, RunID, EQ_Only=True)
    #PlotRSL(Folder, RunID)
    
    # for i in tqdm(range(len(RecordDF.RunID)),desc="Processing Terraces",unit="%"):
        
    #       RunID = RecordDF.RunID.iloc[i]
        
    #       FindTerraces(Folder, RunID)
    #       PlotTerraces(Folder, RunID)