#import modules
from RPM_CRN_Analysis_Functions import *
import matplotlib.pyplot as plt
from matplotlib import rcParams, cm
from scipy.spatial.distance import pdist
import pandas as pd
import numpy as np
import sys

# Set display options to show all rows and columns
pd.set_option('display.max_columns', None)

# setup workspace
Folder = "C:/Users/mh322u/OneDrive - University of Glasgow/NZ_2023/Modelling_Holcene_Terraces/Results/"
ResultsFolder = Folder + "20210213_large_simulation_2/"
PlotsFolder = Folder + "Plots/"

# locad the records and pick one
RecordFile = "TerraceRuns.xlsx"
RecordDF = pd.read_excel(Folder+RecordFile,sheet_name="Sheet1",header=0)

Record =RecordDF[((RecordDF["SeaLevel"] == 1) & (RecordDF["UpliftFreq"] == 3) & (RecordDF["Clustering"] == 1) 
    & (RecordDF["UpliftMag"] == 3) & (RecordDF["Subsidence"] == 1) & (RecordDF["InitSlope"] == 3) & (RecordDF["Tide"] == 1) 
    & (RecordDF["Weathering"] == 1) & (RecordDF["Resistance"] == 1) & (RecordDF["Waves"] == 2))]

RunID = Record.RunID.values[0]
ProfileFileName = str(RunID) + "_ShoreProfile.xz"
Times, SeaLevels, Z, X = ReadShoreProfile(ResultsFolder+ProfileFileName)

# figure properties
# Set up fonts for plots
rcParams['font.family'] = 'sans-serif'
rcParams['font.sans-serif'] = ['arial']
rcParams['font.size'] = 16

# PLOT PROFILE

# plot the profile
fig1 = plt.figure(1,figsize=(16,9))
ax1 = fig1.add_subplot(111)
ax1.set_ylabel("Elevation (m)")
ax1.set_xlabel("Distance (m)")

StartTime = Times[0]
EndTime = Times[-1]
Time = StartTime
TimeInterval = 1000
OldIndex = -9999

if StartTime > EndTime:
    TimeInterval *= -1

# set colour map
ColourMap = cm.bone

while Time >= EndTime:
    
    # Find time
    Index = np.argmin(np.abs(Time-Times))
    
    if Index == OldIndex:
        break
    
    OldIndex = Index

    # plot final result on ax0
    Label = str(int(Time)) + " years"
    Colour = ColourMap(Time/np.max([StartTime,EndTime]))
    ax1.plot(X[Index], Z, ls="-", color=Colour, label=Label)

    Time += TimeInterval


### FIND TERRACES ###
MinTerraceWidth = 3.

#calculate slope
Slope = np.gradient(X[-1])
#Slope = np.insert(Slope,-1,0)
#Slope = np.insert(Slope,0,0)
fig3 = plt.figure(3,(9,9))
ax3a = fig3.add_subplot(211)
ax3a.plot(Slope,Z,'b.')
ax3a.set_xscale("symlog",linthresh=0.01)
ax3a.set_xlabel("Slope (m/m)")
ax3a.set_ylabel("Elevation (m)")

# calculate curvature
Curv = np.gradient(Slope)
#Curv = np.insert(Curv,0,0.)
#CurvMask = np.abs(Curv) <= 0.1
FinalX = X[-1]

Mask = (np.abs(Slope) < 0.1001) & (np.abs(Curv) < 0.01)

# Find terraces
ax3b = fig3.add_subplot(212)
ax3b.plot(Curv,Z,'r.')
ax3b.set_xscale("symlog",linthresh=0.01)
ax3b.set_xlabel("Curvature (1/m)")
ax3b.set_ylabel("Elevation (m)")

# Find cliff incides
SteepIndices = np.where(Mask == 1)[0]

# Find consecutive patches 
SteepPatches = np.split(SteepIndices, np.where(np.diff(SteepIndices) != 1)[0] + 1)
NPatches = len(SteepPatches)

# Check if patches are close and merge accordingly
DistanceThreshold = 2
MergedPatches = []

# Function to merge patches iteratively
# modified from code generated by ChatGPT3.5
def merge_patches(patches, distance, distance_threshold):
    merged_patches = patches.copy()
    merged = True

    while merged:
        merged = False
        i = 0

        while i < len(merged_patches) - 1:
            j = i + 1

            while j < len(merged_patches):
                if (distance[merged_patches[i][-1]]-distance[merged_patches[j][0]]) < distance_threshold:
                    # Merge patches[i] and patches[j]
                    merged_patches[i] = np.concatenate([merged_patches[i], merged_patches[j]])
                    del merged_patches[j]
                    merged = True
                else:
                    j += 1

            i += 1

    return merged_patches
    
# Merge patches iteratively
MergedPatches = merge_patches(SteepPatches, FinalX, MinTerraceWidth)

for i, Patch in enumerate(MergedPatches):
    print(Patch)
    
    ax1.plot(FinalX[Patch],Z[Patch],'r-', lw=2, zorder=9)

# Function to find remaining gaps
# generated by ChatGPT3.5
def find_remaining_gaps(merged_patches):
    remaining_gaps = []
    last_end = -1

    for patch in merged_patches:
        if last_end != -1 and patch[0] - last_end > 1:
            remaining_gaps.append(np.arange(last_end + 1, patch[0]))

        last_end = patch[-1]

    return remaining_gaps

# Find remaining gaps
TerracePatches = find_remaining_gaps(MergedPatches)
print(len(TerracePatches))
#TerracePatches = merge_patches(TerracePatches,FinalX, MinTerraceWidth)


ColourMap = plt.cm.plasma
for i, Patch in enumerate(TerracePatches):
    
    ax1.plot(FinalX[Patch],Z[Patch],'b-', lw=2,zorder=10)
    
fig1.savefig(PlotsFolder+str(RunID)+"_ProfilePlot.png",dpi=300)


# PLOT SEA LEVEL CURVE
SeaDF = pd.read_csv(ResultsFolder + str(RunID) + "_rsl.data", delimiter=" ", header=0)

# plot the profile
fig2 = plt.figure(2,figsize=(16,9))
ax2 = fig2.add_subplot(111)
ax2.set_ylabel("Relative Sea Level (m)")
ax2.set_xlabel("Time (years BP)")
ax2.plot(SeaDF["Time"],SeaDF["RSL"],'b-')
ax2.set_xlim(SeaDF["Time"].max(),SeaDF["Time"].min())
ax2.set_ylim(SeaDF["RSL"].min(),SeaDF["RSL"].max()+5)
fig2.savefig(PlotsFolder+str(RunID)+"_ProfilePlot.png")

# ADD EARTHQUAKES

