#import modules
from RPM_CRN_Analysis_Functions import *
import matplotlib.pyplot as plt
from matplotlib import rcParams, cm
from scipy.spatial.distance import pdist
from scipy.interpolate import interp1d
from scipy.signal import savgol_filter
from scipy.ndimage import gaussian_filter1d
import pandas as pd
import numpy as np
import sys, os
from tqdm import tqdm

# dont plot in spyder pls
%matplotlib qt5
# figure properties
# Set up fonts for plots
rcParams['font.family'] = 'sans-serif'
rcParams['font.sans-serif'] = ['arial']
rcParams['font.size'] = 16

def FindTerraces(Folder, RunID, MaxSlope=0.1, MinWidth=3.):

    ResultsFolder = Folder + "Results/"
    PlotsFolder = Folder + "Plots/"
    
    # load the profile data
    ProfileFileName = str(RunID) + "_ShoreProfile.xz"
    Times, SeaLevels, Z, X = ReadShoreProfile(ResultsFolder+ProfileFileName)
    FinalX = X[-1]
    dZ = np.round(Z[1]-Z[0],1)

    StartTime = Times[0]
    EndTime = Times[-1]
    Time = StartTime
    TimeInterval = 1000
    OldIndex = -9999

    if StartTime > EndTime:
        TimeInterval *= -1
    
    # fig1 = plt.figure(1,(16,9))
    # ax = fig1.add_subplot(111)
    # plt.plot(FinalX,Z,'-',c=[0.5,0.5,0.5])
    
    # do some smoothing?
    # Apply Gaussian smoothing only to the masked part with a small standard deviation
    sigma = 1.5
    SmoothX = gaussian_filter1d(FinalX, sigma=sigma, mode='nearest')

    # plt.plot(SmoothX,Z,'k-')
    
    ### FIND TERRACES ###
    #calculate inverse of slope (i.e. dx/dz so cliffs are zero)
    ZGrad = np.gradient(SmoothX)
    ZGrad[ZGrad == 0] = 0.001
    Slope = dZ/ZGrad
            
    # calculate curvature
    Curv = np.gradient(Slope)
    
    # # Find terraces
    # fig3 = plt.figure(3,(9,9))
    
    # ax3a = fig3.add_subplot(211)
    # ax3a.plot(Slope,Z,'b.')
    # ax3a.set_xscale("symlog",linthresh=0.01)
    # ax3a.set_xlabel("Slope (m/m)")
    # ax3a.set_ylabel("Elevation (m)")

    # ax3b = fig3.add_subplot(212)
    # ax3b.plot(Curv,Z,'r.')
    # ax3b.set_xscale("symlog",linthresh=0.01)
    # ax3b.set_xlabel("Curvature (1/m)")
    # ax3b.set_ylabel("Elevation (m)")
    
    # get Z as a function of X
    #dZ = np.round(Z[1]-Z[0],1)
    
    #get a view of X in the Z dimension via interpolation to help find flats?
    #NewX = np.arange(FinalX[0],FinalX[-1],dZ)
    #interp_func = interp1d(FinalX,Z, kind='linear', fill_value='extrapolate')
    #NewZ = interp_func(NewX)
    
    #RealSlope = np.gradient(NewZ)
    #RealCurv = np.gradient(RealSlope)
    #fig1 = plt.figure(1,(16,9))
    #ax1 = fig1.add_subplot(211)
    #ax1.plot(FinalX,Z,'k-')
    #ax1.plot(NewX,NewZ,'b-')
    
    #ax2 = fig1.add_subplot(212)
    #ax2.set_yscale("symlog",linthresh=0.01)
    #ax2.plot(NewX,RealSlope,'b.')
    
    # Mask to find steep sections with low curvature
    Mask = (np.abs(Slope) > MaxSlope)
    
    #Mask2 = ()
    # ax.plot(FinalX[Mask], Z[Mask],'ro')
    # ax.plot(FinalX[~Mask], Z[~Mask],'b.')
    #plt.show()
    
        
    # Find cliff indices
    SteepIndices = np.where(Mask == 1)[0]
    # GentleIndices = np.where(Mask == 0)[0]
    
    #smooth the inbetween bits
    
    # In gentle areas, further mask by slope
    #DiffX = np.insert(np.diff(X[-1]),-1,0)
    
    # Find terrace indices
    #GentleMask = ((Mask == 0) & (np.abs(Slope) > 1))
    #TerraceIndices = np.where(GentleMask == 1)[0]
    
    
    # Find consecutive patches 
    SteepPatches = np.split(SteepIndices, np.where(np.diff(SteepIndices) != 1)[0] + 1)
    #NPatches = len(TerracePatches)
    
    #print(TerracePatches)

    # Check if patches are close and merge accordingly
    DistanceThreshold = 10

    # Function to merge patches iteratively
    # modified from code generated by ChatGPT3.5
    def merge_patches(patches, distance, distance_threshold):
        merged_patches = patches.copy()
        merged = True

        while merged:
            merged = False
            i = 0

            while i < len(merged_patches) - 1:
                j = i + 1

                while j < len(merged_patches):
                    if (distance[merged_patches[i][-1]]-distance[merged_patches[j][0]]) < distance_threshold:
                        # Merge patches[i] and patches[j]
                        merged_patches[i] = np.arange(merged_patches[i][0],merged_patches[j][-1]+1)
                        #np.concatenate([merged_patches[i], merged_patches[j]])
                        del merged_patches[j]
                        merged = True
                    else:
                        j += 1

                i += 1

        return merged_patches
        
    # Merge patches iteratively
    SteepPatches = merge_patches(SteepPatches, FinalX, DistanceThreshold)
    
    # for i, Patch in enumerate(SteepPatches):
        
    #     ax.plot(FinalX[Patch], Z[Patch],'r-')
    
    
    
    # Function to find remaining gaps
    # generated by ChatGPT3.5
    def find_remaining_gaps(merged_patches):
        remaining_gaps = []
        last_end = -1

        for patch in merged_patches:
            if last_end != -1 and patch[0] - last_end > 1:
                remaining_gaps.append(np.arange(last_end + 1, patch[0]))

            last_end = patch[-1]

        return remaining_gaps

    # Find remaining gaps
    if len(SteepPatches) > 1:
        GentlePatches = find_remaining_gaps(SteepPatches)
        GentlePatches = merge_patches(GentlePatches, Z, 1.)
    
    else:
        GentlePatches = []
    # for i, Patch in enumerate(GentlePatches):
    #     ax.plot(FinalX[Patch], Z[Patch],'b-')
        
    # sys.exit()
    
    # Smooth Gentle Patches
    # SmoothX = FinalX
    # for i, Patch in enumerate(GentlePatches):
    #     print(Patch)
    #     SmoothX[Patch] = savgol_filter(FinalX[Patch],11,2)
        
    # for i, Patch in enumerate(SteepPatches):
    #     plt.plot(FinalX[Patch],Z[Patch],'r-')
    
    # plt.plot(SmoothX,Z,'r.')
    # plt.show()
    # sys.exit()
    
    # Save Terraces to a new DF
    Columns = ["TerraceID","StartIndex","EndIndex","Width","MeanElev","ElevChange","Slope"]
    TerracesDF = pd.DataFrame(columns=Columns)
    
    for i, Terrace in enumerate(GentlePatches):
        Width = FinalX[Terrace[0]]-FinalX[Terrace[-1]]
        if Width < MinWidth:
            continue
        
        ElevChange = Z[Terrace[0]]-Z[Terrace[-1]]
        NewRow = [i,Terrace[0],Terrace[-1],Width,np.mean(Z[Terrace]),ElevChange,ElevChange/Width]
        TerracesDF = pd.concat([TerracesDF,pd.DataFrame([NewRow], columns=Columns)], ignore_index=True)
    
    TerracesDF.to_excel(ResultsFolder + str(RunID)+"_Terraces.xlsx")

def PlotTerraces(Folder, RunID):
    
    ResultsFolder = Folder + "Results/"
    PlotsFolder = Folder + "Plots/"

    # load the profile data
    ProfileFileName = str(RunID) + "_ShoreProfile.xz"
    Times, SeaLevels, Z, X = ReadShoreProfile(ResultsFolder+ProfileFileName)
    FinalX = X[-1]
    
    # load terraces 
    TerraceFile = str(RunID) + "_Terraces.xlsx"
    
    #check if file exists and run terrace finder if needed
    if not os.path.exists(ResultsFolder+TerraceFile):
        FindTerraces(Folder, RunID)
    
    TerracesDF = pd.read_excel(ResultsFolder+TerraceFile)
            
    # create figure and axes
    fig1 = plt.figure(1,figsize=(16,9))
    ax1 = fig1.add_subplot(111)
    ax1.set_ylabel("Elevation (m)")
    ax1.set_xlabel("Distance (m)")

    # set colour map
    ColourMap = cm.bone

    #set up and loop over time to plot
    Time = Times[0]
    TimeInterval = -1000
    StartTime = Time
    EndTime = Times[-1]
    OldIndex=-9999
    
    while Time >= EndTime:
        
        # Find time
        Index = np.argmin(np.abs(Time-Times))
    
        if Index == OldIndex:
            break
        
        OldIndex = Index
        
        # plot final result on ax0
        Label = str(int(Time)) + " years"
        Colour = ColourMap(Time/np.max([StartTime,EndTime]))
        ax1.plot(X[Index], Z, ls="-", color=Colour, label=Label)

        Time += TimeInterval

    for i,Terrace in TerracesDF.iterrows():
        
        # make sure indices are ints
        Ind1 = Terrace.StartIndex.astype(int)
        Ind2 = Terrace.EndIndex.astype(int)
        ax1.plot(FinalX[Ind1:Ind2],Z[Ind1:Ind2],'r-', lw=2, zorder=9)
    
    ax1.text(0.05,0.9,"No. Terraces: " + str(len(TerracesDF)), transform=ax1.transAxes)
    fig1.savefig(PlotsFolder+str(RunID)+"_ProfilePlot.png")
    fig1.clf()

# # PLOT SEA LEVEL CURVE
# SeaDF = pd.read_csv(ResultsFolder + str(RunID) + "_rsl.data", delimiter=" ", header=0)

# # plot the profile
# fig2 = plt.figure(2,figsize=(16,9))
# ax2 = fig2.add_subplot(111)
# ax2.set_ylabel("Relative Sea Level (m)")
# ax2.set_xlabel("Time (years BP)")
# ax2.plot(SeaDF["Time"],SeaDF["RSL"],'b-')
# ax2.set_xlim(SeaDF["Time"].max(),SeaDF["Time"].min())
# ax2.set_ylim(SeaDF["RSL"].min(),SeaDF["RSL"].max()+5)
# fig2.savefig(PlotsFolder+str(RunID)+"_ProfilePlot.png")

# # ADD EARTHQUAKES

if __name__ == "__main__":
    
    # Set display options to show all rows and columns
    # pd.set_option('display.max_columns', None)

    # setup workspace
    Folder = "C:/Users/mh322u/OneDrive - University of Glasgow/NZ_2023/Modelling_Holcene_Terraces/Results/"
    
    # locad the records and pick one
    RecordFile = "TerraceRuns.xlsx"
    RecordDF = pd.read_excel(Folder+RecordFile,sheet_name="Sheet1",header=0)
    
    # Minimum Width (default is 3m)
    # Max Slope (default is 0.1 m/m)
    # MinWidth=3.

    #Record =RecordDF[((RecordDF["SeaLevel"] == 1) & (RecordDF["UpliftFreq"] == 3) & (RecordDF["Clustering"] == 1) 
    #    & (RecordDF["UpliftMag"] == 3) & (RecordDF["Subsidence"] == 1) & (RecordDF["InitSlope"] == 3) & (RecordDF["Tide"] == 1) 
    #    & (RecordDF["Weathering"] == 1) & (RecordDF["Resistance"] == 1) & (RecordDF["Waves"] == 2))]

    # RunID = Record.RunID.values[0]
    #RunID = 6
    #FindTerraces(Folder, RunID)
    #PlotTerraces(Folder, RunID)    
    
    for i in tqdm(range(len(RecordDF.RunID)),desc="Processing Terraces",unit="%"):
        
          RunID = RecordDF.RunID.iloc[i]
        
          FindTerraces(Folder, RunID)
          PlotTerraces(Folder, RunID)